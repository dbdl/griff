#!/bin/bash
# -*- Mode: shell; tab-width: 4; indent-tabs-mode: t; -*-
#
# Modified: Tue Jan 27 01:42:25 2009
#
# Backup script. See README.
#

set -e
set -a # automatically export all variables & functions
me=${0##*/}

# Constants
true=0 # shell defaults to opposite
false=1
# Upon script installation, this will be set up as ${datadir}
myres="/home/michel/Desktop/Sauvegardes/bk_nas_samba"

# Task (main operation)
A=eana
B=wk
C="aegis archeo cvs mail michel mysql pak svn trac www"
task=${A}_${B}
task_list=$myres/${task}.list
pre_backup_tasks=
post_backup_tasks=bkn_preserve_backup
current_backup_dir=
current_backup_date=

# Log
d=$(date "+%F_%T")
log=/var/log/$me_${task}_${d}.log
errlog=${log%.log}.err
rsy_log=/var/log/rsync_${task}_${d}.log
rsy_errlog=${rsy_log%.log}.err

# Operation variables (depends on task)
fs_type=ext2
mount_options_bsf=""
remote_fs="//kish/${A}"
remote_user=${A}
nas_creds=$myres/nas_creds.${A}
mount_options_nas="-t smbfs -o lfs,username=${remote_user},credentials=$nas_creds"
mount_point_nas="/backup/nas/${A}/${B}"
big_sparse_file="$mount_point_nas/backup.$fs_type"
bsf_just_created=$false
mount_point_bsf="/backup/bsf/${A}/${B}"
options="-ravi"
exclude="--exclude-from=EXCLUDES"
source=${C}
info="$mount_point_bsf/README"
dest="$mount_point_bsf/backup"

# Variable variables
loop_dev=/dev/loop0 # default
mount_point_test_service=
mount_point_test_type=

bkn_log() {
	echo "$*"
}

bkn_warn() {
	echo "$me: WARNING: $*" >&2
}

bkn_error() {
	echo "$me: ERROR: $*" >&2
}

bkn_fatal() {
	echo "$*" >&2
	exit 1
}

bkn_check_myres() {
	if [ ! -d "$myres" ] ; then
		bkn_fatal "Variable myres is set to: $myres. This directory does not exists. Please change myres."
	fi
	if [ ! -f "$myres/nas_creds.${A}" ] ; then
		bkn_fatal "You must create a NAS credentials file: $myres/nas_creds.${A}"
	fi
	if [ ! -f "$myres/${task}.list" ] ; then
		bkn_fatal "$myres/${task}.list does not exists: please create it."
	fi
}

bkn_write_index_line() {
	# args required: dir name date size sizeeff
	echo "$1;$2;$3;$4;$5" >> "$mount_point_bsf/INDEX"
}

bkn_do_real_backup() {
	#set -x
	(
		#set -x
		if [ -n "$task_list" ] ; then
			src=$task_list
		else
			src=$source
		fi
		bkn_log "Source list: $src"
		if [ ! -d "$dest" ] ; then
			bkn_log "Creating destination directory: $dest"
			mkdir -p "$dest"
		fi
		rsync $options \
			$exclude \
			$src \
			$dest >$rsy_log 2>$rsy_errlog
		return $?
	) >>$log 2>>$errlog
	return $?
}

bkn_launch_backup() {
	bkn_log "Launching backup..."
	for i in $pre_backup_tasks ; do
		bkn_log "Launching pre-backup task: $i..."
		$i >>$log 2>>$errlog
	done
	# pre-backup tasks (ex: lock databases)
	bkn_log "Real backup starting..."
	bkn_do_real_backup
	# post-backup tasks (ex: unlock databases)
	for i in $post_backup_tasks ; do
		bkn_log "Launching post-backup task: $i..."
		$i >>$log 2>>$errlog
	done
	bkn_log "Computing backup size..."
	size=$(du -s -b $dest)
	sizeeff=0
	bkn_log "Writting INDEX entry..."
	bkn_write_index_line $current_backup_dir $task $current_backup_date $size $sizeeff
	bkn_log "Finished backup."
	return $true
}

bkn_get_nas_mount_info() {
	# small trick to parse two variables in awk back into the shell
	t=$(df -T $mount_point_nas | sed -e 1d | \
		awk '{ 
print "mount_point_test_service="$1"\nmount_point_test_type="$2 
}')
	bkn_log "t=$t"
	eval $t
	return $?
}

bkn_is_nas_mounted() {
	# is this a remote filesystem
	case $mount_point_test_type in
		smbfs|cifs) return $true ;;
		*) return $false ;;
	esac
}

bkn_is_nas_service_ok() {
	case $mount_point_test_service in
		$remote_fs) return $true ;; # NAS is mounted and ok
		*) return $false ;;
	esac
}

bkn_mount_nas() {
    mkdir -p $mount_point_nas || return $false
    mount $mount_options_nas \
		$remote_fs \
		$mount_point_nas
    return $?
}

bkn_umount_nas() {
	umount $mount_point_nas
	return $?
}

bkn_mount_bsf() {
    mkdir -p $mount_point_bsf || return $false
    mount $mount_options_bsf \
		$loop_dev \
		$mount_point_bsf
	return $?
}

bkn_umount_bsf() {
	umount $mount_point_bsf
	return $?
}

bkn_create_big_sparse() {
    dd if=/dev/zero of=$big_sparse_file bs=1M count=1 seek=150000
	return $?
}

bkn_check_bsf_is_backup_filesystem() {
	t=$(file -b $big_sparse_file)
	case $( echo $t | awk 'BEGIN { fstype="unknown" }
/Linux.*/ { fstype="Linux" }
/Linux.*ext2/ { fstype="Linux.ext2" }
END { print fstype }') in
		Linux) bkn_warn "filesystem identified as 'Linux', but without complete type." ;;
		Linux.ext2) return $true ;;
		*) return $false ;;
	esac
}

bkn_create_backup_filesystem() {
    mkfs.$fs_type $loop_dev || bkn_error "creating filesystem $fs_type on $loop_dev."
	return $?
}

bkn_check_backup_filesystem() {
	if [ -w "$mount_point_bsf" ] ; then
		u=$(umask)
		umask 0222
		if [ ! -f "$mount_point_bsf/MANIFEST" ] ; then
			bkn_log "Copy MANIFEST to FS in BSF..."
			cp $myres/MANIFEST $mount_point_bsf
		fi
		if [ ! -f "$mount_point_bsf/README" ] ; then
			bkn_log "Copy README to FS in BSF..."
			cp $myres/README $mount_point_bsf
		fi
		umask $u
	else
		bkn_fatal "Could not write to FS in BSF"
	fi
}

bkn_setup_loop_device() {
    loop_dev=$(losetup -f) # find first unused loop device
    losetup $loop_dev $big_sparse_file
	return $?
}

bkn_release_loop_device() {
	losetup -d $loop_dev
	return $?
}

bkn_verify_task_list() {
	t=task_${A}_${B}
	if [ -f "$t" ] ; then
		tf=$(mktemp)
		cat "$t" | while read l ; do
			if [ -d "$l" ] ; then
				echo \"$l\" >> $tf
			else
				echo "$l: not a valid directory" >> $errlog
			fi
		done
		task_list=$(cat $tf|xargs)
		rm -f $tf
		return $true
	else
		echo "ERROR: Task list not found." >> $errlog
		return $false
	fi
}

bkn_preserve_backup() {
	current_backup_date=$(date "+%F_%T")
	current_backup_dir=backup.${current_backup_date}
	bkn_log "Creating snapshot: $current_backup_date..."
	cp -al "$mount_point_bsf/backup" "$mount_point_bsf/$current_backup_dir"
}

bkn_debug_shell() {
	prompt_colour="\[\033[0;31m\]"
	no_colour="\[\033[0m\]"
	case $TERM in
		xterm*|gnome*|konsole*)
			long_title='\u@\h - ${me} shell'
			short_title='\W'
			titlebar="\[\033]0;$short_title\007\033]2;$long_title\007\]"
			;;
		*)
			titlebar="${me} shell"
			;;
	esac
	export PS1="${titlebar}${prompt_colour}${me} shell > $no_colour"
	export PS2='>> '
	
	$SHELL --norc
}

bkn_setup() {

	bkn_log "Verify myres ($myres)..."

	bkn_check_myres

	bkn_log "Verify task list ($task)..."

	bkn_verify_task_list

	bkn_log "Test NAS mount point..."

	if [ ! -d $mount_point_nas ] ; then
		bkn_fatal "NAS mount point must be created first ($mount_point_nas)"
	fi
	
	bkn_get_nas_mount_info
	
	bkn_log "mount_point_test_type = $mount_point_test_type"
	
	if bkn_is_nas_mounted ; then
		bkn_fatal "NAS already mounted"
	fi
	
	bkn_log "Mount NAS share..."
	
	bkn_mount_nas || bkn_fatal "Failed to mount NAS"
	
	bkn_get_nas_mount_info
	
	bkn_log "NAS service = $mount_point_test_service"
	
	if ! bkn_is_nas_service_ok ; then
		bkn_fatal "NAS is not the service expected"
	fi
	
	bkn_log "NAS ok."
	
	bkn_log "Test big sparse file on NAS..."
	
	if [ -f $big_sparse_file ] ; then
		bkn_log "Do not create big sparse file, ok."
	else
		bkn_log "Create big sparse file on NAS share..."
		bkn_create_big_sparse || bkn_fatal "Failed to create BSF"
		bsf_just_created=$true
	fi

	bkn_log "Setup loop device"
	
	bkn_setup_loop_device || bkn_fatal "Failed to setup loop device"
	
	bkn_log "Loop device in use = $loop_dev"

	bkn_log "Test filesystem in big sparse file..."

	if [ $bsf_just_created -eq $true ] ; then
		bkn_log "Create filesystem in this file..."
		bkn_create_backup_filesystem || bkn_fatal "Failed to create FS in BSF"
	else
		bkn_log "Do not create filesystem in big sparse file, ok."		
	fi

	bkn_check_bsf_is_backup_filesystem || bkn_fatal "BSF is invalid"

	bkn_log "Mount this filesystem..."
	
	bkn_mount_bsf || bkn_fatal "Failed to mount BSF"
	
	bkn_check_backup_filesystem

}

bkn_backup() {

	bkn_launch_backup

}

bkn_release() {

	bkn_log "Releasing resources..."

	bkn_log "Umount FS in BSF..."
	bkn_umount_bsf

	bkn_log "Release loop device..."
	bkn_release_loop_device

	bkn_log "Umount NAS..."
	bkn_umount_nas

}

#################
# GUI functions #
#################

# simple text gui:
#   echo menu, read menu input
# advanced text gui: ncurses
# gui: zenity

bkn_list_backups() {
	bkn_log "EXPERIMENTAL FUNCTION"
	cd "$mount_point_bsf"
	l=$(\ls -1d backup.*)
	for i in $l; do
		t=$(grep ^$i INDEX)
		if [ $? -ne 0 ] ; then
			bkn_warn "malformed INDEX line for $i"
			continue
		fi
		t=$(grep ^$i INDEX | awk -F\; '{print "dir="$1"\nname="$2"\ndate="$3"\nsize="$4"\nsizeeff="$5 }')
# 		bkn_log "t=$t"
		eval $t
		echo
		echo "dir     = $dir"
		echo "name    = $name"
		echo "date    = $date"
		echo "size    = $size"
		echo "sizeeff = $sizeeff"
		echo
	done
	cd ->/dev/null
}

####################
# Main entry point #
####################

case "$1" in
	shell)
		bkn_debug_shell
		exit 0
		;;
	debug)
		# Trap functions very well, we enter debug shell
		# even if we 'exit' through bkn_fatal
		# but still we miss the bkn_release because
		# when the debug shell finishes, shell actually exits
		# FIXME: disable trap when entering in debug shell...
		trap bkn_debug_shell EXIT
		bkn_setup
		bkn_debug_shell
		echo "FIN"
		bkn_release
		exit 0
		;;
	backup_and_debug)
		trap bkn_debug_shell EXIT
		bkn_setup
		bkn_backup
		bkn_debug_shell
		bkn_release
		exit 0
		;;
	*) echo "normal operation..." ;;
esac

bkn_setup
bkn_backup
bkn_release

# Stages:
# - START
# - NAS_MOUNTED
# - NAS_MOUNTED_OK
# - LOOP_OK
# - BSF_OK
# - BSF_MOUNTED
# - BSF_MOUNTED_OK
# ...

# FS in BSF contents
# /MANIFEST <- what is this ?
# /README <- readme from dbdlb/mbclb
# /backup <- where to store backuped files&dirs
# /log <- real backup logs

