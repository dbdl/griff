#!/bin/bash
# -*- Mode: shell; tab-width: 4; indent-tabs-mode: t; -*-
#
# Modified: Sun Feb  1 16:48:58 2009
#
# Backup script. See README.
#

set -e
set -a # automatically export all variables & functions
me=${0##*/}

# Constants
true=0 # shell defaults to opposite
false=1
operation_modes="shell|debug|backup_and_debug"
# Upon script installation, this will be set up as ${datadir}
myres="/home/michel/Desktop/Sauvegardes/bk_nas_samba"

# Task (main operation)
A=eana
B=wk
C="aegis archeo cvs mail michel mysql pak svn trac www"
task=${A}_${B}
task_list=$myres/task_${task}.list
task_list_parsed=
backup_method=rsync
pre_backup_tasks=
post_backup_tasks=
current_backup_dir=
current_backup_date=

# Log
logdate=$(date "+%F_%T")
log=/var/log/$me_${task}_${logdate}.log
errlog=${log%.log}.err
rsy_log=/var/log/${backup_method}_${task}_${logdate}.log
rsy_errlog=${rsy_log%.log}.err

# Operation variables (depends on task)
fs_type=ext3
mount_options_bsf=""
nas="//kish"
remote_fs="${nas}/${A}"
remote_user=${A}
nas_creds=$myres/nas_creds.${A}
mount_options_nas="-t smbfs -o lfs,username=${remote_user},credentials=$nas_creds"
mount_point_nas="/backup/nas/${A}/${B}"
big_sparse_file="$mount_point_nas/backup.$fs_type"
bsf_just_created=$false
mount_point_bsf="/backup/bsf/${A}/${B}"
options="-ravi"
exclude="--exclude-from=EXCLUDES"
source=${C}
info="$mount_point_bsf/README"
backup_dir=backup
dest="$mount_point_bsf/$backup_dir"

bkn_update_vars() {
	task=${A}_${B}
	task_list=$myres/task_${task}.list
	log=/var/log/$me_${task}_${logdate}.log
	errlog=${log%.log}.err
	rsy_log=/var/log/${backup_method}_${task}_${logdate}.log
	rsy_errlog=${rsy_log%.log}.err
	remote_fs="${nas}/${A}"
	remote_user=${A}
	nas_creds=$myres/nas_creds.${A}
	mount_options_nas="-t smbfs -o lfs,username=${remote_user},credentials=$nas_creds"
	mount_point_nas="/backup/nas/${A}/${B}"
	big_sparse_file="$mount_point_nas/backup.$fs_type"
	mount_point_bsf="/backup/bsf/${A}/${B}"
	source=${C}
	info="$mount_point_bsf/README"
	dest="$mount_point_bsf/$backup_dir"
}

# Variable variables
loop_dev=/dev/loop0 # default
mount_point_test_service=
mount_point_test_type=
last_backup_dir=

bkn_log() {
	echo "$*"
}

bkn_warn() {
	echo "$me: WARNING: $*" >&2
}

bkn_error() {
	echo "$me: ERROR: $*" >&2
}

bkn_fatal() {
	echo "$*" >&2
	exit 1
#   Trap ERR not working at the moment...
# 	return $false # with set -e this will trigger ERR signal
}

bkn_ERR() {
	read -t 3 -p "ERROR trapped, continue ? [y/N]" -n 1 $r
	case $r in
		y|Y) return $true ;;
		*) exit
	esac
}

bkn_check_myres() {
	if [ ! -d "$myres" ] ; then
		bkn_fatal "Variable myres is set to: $myres. This directory does not exists. Please setup myres correctly."
	fi
	if [ ! -f "$myres/nas_creds.${A}" ] ; then
		bkn_fatal "NAS credentials file not found. You must create a NAS credentials file: $myres/nas_creds.${A}"
	fi
	if [ ! -f "$task_list" ] ; then
		bkn_fatal "Task list not found. You must create a task list: $task_list"
	fi
}

bkn_write_index_line() {
	# args required: dir name date size sizeeff
	echo "$1;$2;$3;$4;$5" >> "$mount_point_bsf/INDEX"
}

bkn_current_backup_status() {
	bkn_log \
"task           : ${task:-<undefined>}
backup dir     : ${current_backup_dir:-<undefined>}
backup date    : ${current_backup_date:-<undefined>}
size           : ${size:-<undefined>}
effective size : ${sizeeff:-<undefined>}"
}

bkn_get_last_backup_dir() {
	bkn_log "Searching for last backup dir..."
	if [ -f "$mount_point_bsf/INDEX" ] ; then
		i=$(tail -1 "$mount_point_bsf/INDEX"|awk -F\; '{print $1}')
	else
		bkn_log "INDEX not found"
	fi
	if [ ! -z "$i" ] && [ -d "$mount_point_bsf/$i" ] ; then
		last_backup_dir=${i##*/}
		return $true
	else
		bkn_log "Last backup dir not found in INDEX, trying ls..."
		l=$(ls -1trd "$mount_point_bsf" | tail -1)
		if [ ! -z "$l" ] && [ -d "$l" ] ; then
			# test if it is not the .
			r_parent=$(realpath $mount_point_bsf)
			r_l=$(realpath $l)
			if [ $r_parent != $r_l ] ; then
				bkn_log "Found: $l"
				last_backup_dir=${l##*/}
				return $true
			else
				bkn_log "Not found (directory empty)"
				return $false
			fi
		else
			bkn_error "Not found (ls error)"
			return $false
		fi
	fi
	bkn_fatal "Should not happen"
}

bkn_do_real_rsync_backup() {
	# The ( rsync ) construct seems to behave strangely
	# with the trap EXIT trick... I remove it temporarely.

	if [ -n "$task_list_parsed" ] ; then
		src=$task_list_parsed
	else
		src=$source
	fi
	bkn_log "Source list: $src"

	if [ -f EXCLUDES ] ; then
		ex=$exclude
	else
		ex=
	fi

	bkn_log "Real rsync: rsync $options $ex $src $dest"
	rsync $options \
		$ex \
		$src \
		$dest >$rsy_log 2>$rsy_errlog || bkn_error "rsync error"

	# We've lost $? so don't bother return it...
}

bkn_preserve_backup() {
	# args: current next
	curr=$1
	next=$2
	bkn_log "Creating snapshot: $mount_point_bsf/$curr - $mount_point_bsf/$next ..."
	cp -al "$mount_point_bsf/$curr" "$mount_point_bsf/$next"
	return $?
}

bkn_setup_rsync_dest() {
	bkn_log "Prepare delta (snapshot)..."
	current_backup_date=$(date "+%F_%T")
	if bkn_get_last_backup_dir ; then
		# snapshot
		current_backup_dir=$last_backup_dir
		next_backup_dir=${backup_dir}.${current_backup_date}
		bkn_preserve_backup $current_backup_dir $next_backup_dir
		bkn_log "Delta finished."
		current_backup_dir=$next_backup_dir
	else
		# full
		bkn_log "Last backup dir not found, creating a new full backup."
		current_backup_dir=${backup_dir}.${current_backup_date}
	fi
	dest="$mount_point_bsf/$current_backup_dir"
	mkdir -p "$dest"
	bkn_log "Backup dir is now: $dest"
}

bkn_launch_backup() {
	bkn_log "Launching backup..." # pre-backup tasks (ex: lock databases)
	for i in $pre_backup_tasks ; do
		bkn_log "Launching pre-backup task: $i..."
		$i >>$log 2>>$errlog
	done
	bkn_log "Real backup starting..."
	case $backup_method in
		rsync) # rsync needs a target directory
			bkn_setup_rsync_dest
			bkn_do_real_rsync_backup
			bkn_log "Computing backup size..."
			size=$(du -s -b $dest|awk '{print $1}')
			sizeeff=0 # FIXME: don't known how to compute this...
			bkn_log "Writting INDEX entry..."
			bkn_current_backup_status # log current status
			bkn_write_index_line $current_backup_dir $task $current_backup_date $size $sizeeff
			;;
		git) # git needs a repository
			;;
	esac
	# post-backup tasks (ex: unlock databases)
	for i in $post_backup_tasks ; do
		bkn_log "Launching post-backup task: $i..."
		$i >>$log 2>>$errlog
	done
	bkn_log "Finished backup."
	return $true
}

bkn_get_nas_mount_info() {
	# small trick to parse two variables in awk back into the shell
	t=$(df -T $mount_point_nas | sed -e 1d | \
		awk '{ 
print "mount_point_test_service="$1"\nmount_point_test_type="$2 
}')
# 	bkn_log "t=$t"
	eval $t
	return $?
}

bkn_is_nas_mounted() {
	# is this a remote filesystem
	case $mount_point_test_type in
		smbfs|cifs) return $true ;;
		*) return $false ;;
	esac
}

bkn_is_nas_service_ok() {
	case $mount_point_test_service in
		$remote_fs) return $true ;; # NAS is mounted and ok
		*) return $false ;;
	esac
}

bkn_mount_nas() {
    mkdir -p $mount_point_nas || return $false
    mount $mount_options_nas \
		$remote_fs \
		$mount_point_nas
    return $?
}

bkn_umount_nas() {
	umount $mount_point_nas
	return $?
}

bkn_mount_bsf() {
    mkdir -p $mount_point_bsf || return $false
    mount $mount_options_bsf \
		$loop_dev \
		$mount_point_bsf
	return $?
}

bkn_umount_bsf() {
	umount $mount_point_bsf
	return $?
}

bkn_create_big_sparse() {
    dd if=/dev/zero of=$big_sparse_file bs=1M count=1 seek=150000
	return $?
}

bkn_check_bsf_is_backup_filesystem() {
	t=$(file -b $big_sparse_file)
	case $( echo $t | awk 'BEGIN { fstype="unknown" }
/Linux.*/ { fstype="Linux" }
/Linux.*ext2/ { fstype="Linux.ext2" }
END { print fstype }') in
		Linux) bkn_warn "filesystem identified as 'Linux', but without complete type." ;;
		Linux.ext2) return $true ;;
		*) return $false ;;
	esac
}

bkn_create_backup_filesystem() {
    mkfs.$fs_type $loop_dev || bkn_error "creating filesystem $fs_type on $loop_dev."
	return $?
}

bkn_check_backup_filesystem() {
	if [ -w "$mount_point_bsf" ] ; then
		u=$(umask)
		umask 0222
		if [ ! -f "$mount_point_bsf/MANIFEST" ] ; then
			bkn_log "Copy MANIFEST to FS in BSF..."
			cp $myres/MANIFEST $mount_point_bsf
		fi
		if [ ! -f "$mount_point_bsf/README" ] ; then
			bkn_log "Copy README to FS in BSF..."
			cp $myres/README $mount_point_bsf
		fi
		umask $u
	else
		bkn_fatal "Could not write to FS in BSF"
	fi
}

bkn_setup_loop_device() {
    loop_dev=$(losetup -f) # find first unused loop device
    losetup $loop_dev $big_sparse_file
	return $?
}

bkn_release_loop_device() {
	losetup -d $loop_dev
	return $?
}

bkn_verify_task_list() {
	t=$task_list
	if [ -f "$t" ] ; then
		tf=$(mktemp)
		cat "$t" | while read l ; do
			if [ -d "$l" ] ; then
				echo \"$l\" >> $tf
			else
				echo "$l: not a valid directory" >> $errlog
			fi
		done
		task_list_parsed=$(cat $tf|xargs)
		rm -f $tf
		return $true
	else
		bkn_fatal "Task list not found: $t."
	fi
}

bkn_debug_shell() {
# 	trap 'echo "EXIT disabled, hit C-c to exit."' EXIT
# 	prompt_colour="\[\033[0;31m\]"
# 	no_colour="\[\033[0m\]"
# 	case $TERM in
# 		xterm*|gnome*|konsole*)
# 			long_title='\u@\h - ${me} shell'
# 			short_title='\W'
# 			titlebar="\[\033]0;$short_title\007\033]2;$long_title\007\]"
# 			;;
# 		*)
# 			titlebar="${me} shell"
# 			;;
# 	esac
# 	export PS1="${titlebar}${prompt_colour}${me} shell > $no_colour"
# 	export PS2='>> '
	$SHELL --rcfile $myres/bashrc
}

bkn_setup() {

	bkn_log "Verify myres ($myres)..."

	bkn_check_myres

	bkn_log "Verify task list ($task)..."

	bkn_verify_task_list

	bkn_log "Test NAS mount point..."

	if [ ! -d $mount_point_nas ] ; then
		bkn_fatal "NAS mount point must be created first ($mount_point_nas)"
	fi
	
	bkn_get_nas_mount_info
	
	bkn_log "Current mount point FS type: $mount_point_test_type"
	
	if bkn_is_nas_mounted ; then
		bkn_fatal "NAS already mounted"
	fi
	
	bkn_log "Mount NAS share..."
	
	bkn_mount_nas || bkn_fatal "Failed to mount NAS"
	
	bkn_get_nas_mount_info
	
	bkn_log "Current NAS service: $mount_point_test_service"
	
	if ! bkn_is_nas_service_ok ; then
		bkn_fatal "NAS is not the service expected"
	fi
	
	bkn_log "NAS ok."
	
	bkn_log "Test big sparse file on NAS..."
	
	if [ -f $big_sparse_file ] ; then
		bkn_log "Do not create big sparse file, ok."
	else
		bkn_log "Create big sparse file on NAS share..."
		bkn_create_big_sparse || bkn_fatal "Failed to create BSF"
		bsf_just_created=$true
	fi

	bkn_log "Setup loop device"
	
	bkn_setup_loop_device || bkn_fatal "Failed to setup loop device"
	
	bkn_log "Loop device in use = $loop_dev"

	bkn_log "Test filesystem in big sparse file..."

	if [ $bsf_just_created -eq $true ] ; then
		bkn_log "Create filesystem in this file..."
		bkn_create_backup_filesystem || bkn_fatal "Failed to create FS in BSF"
	else
		bkn_log "Do not create filesystem in big sparse file, ok."		
	fi

	bkn_check_bsf_is_backup_filesystem || bkn_fatal "BSF is invalid"

	bkn_log "Mount this filesystem..."
	
	bkn_mount_bsf || bkn_fatal "Failed to mount BSF"
	
	bkn_check_backup_filesystem

}

bkn_backup() {

	bkn_launch_backup

}

bkn_release() {

	bkn_log "Releasing resources..."

	bkn_log "Umount FS in BSF..."
	bkn_umount_bsf

	bkn_log "Release loop device..."
	bkn_release_loop_device

	bkn_log "Umount NAS..."
	bkn_umount_nas

}

#################
# GUI functions #
#################

# simple text gui:
#   echo menu, read menu input
# advanced text gui: ncurses
# gui: zenity

bkn_list_backups() {
	bkn_log "EXPERIMENTAL FUNCTION"
	cd "$mount_point_bsf"
	l=$(\ls -1d backup.*)
	for i in $l; do
		t=$(grep ^$i INDEX)
		if [ $? -ne 0 ] ; then
			bkn_warn "malformed INDEX line for $i"
			continue
		fi
		t=$(grep ^$i INDEX | awk -F\; '{print "dir="$1"\nname="$2"\ndate="$3"\nsize="$4"\nsizeeff="$5 }')
# 		bkn_log "t=$t"
		eval $t
		echo
		echo "dir     = $dir"
		echo "name    = $name"
		echo "date    = $date"
		echo "size    = $size"
		echo "sizeeff = $sizeeff"
		echo
	done
	cd ->/dev/null
}

####################
# Main entry point #
####################

# Command line options & arguments
myoptions="hd:A:B:C:N:"
# Options explained:
usage() {
	echo "usage: $me [options]"
	echo
	echo "options:"
	echo
	echo -e "  h       this help"
	echo
	echo -e "  d<mode> operation mode: $operation_modes"
	echo
	echo -e "  A       task A part (name)"
	echo -e "  B       task B part (sub-name)"
	echo -e "  C       task C part (sources)"
	echo -e "  N       NAS hostname"
	echo
	exit 0
}
# FIXME: long options: maybe declare '-' in myoptions
# and use this trick:
# http://forum.ubuntu-fr.org/viewtopic.php?pid=2229021#p2229021

while getopts $myoptions o
do
  case $o in
	  h )
		  usage
		  ;;
	  d ) [ -z "$OPTARG" ] && usage
		  d=$OPTARG
		  case $d in
 			  shell|debug|backup_and_debug) # how to test $d in $operation_modes??
				  mode=$d ;;
			  *) bkn_error "invalid mode: $d, operation modes are: $operation_modes"
				  usage ;;
		  esac
		  ;;
      A ) [ -z "$OPTARG" ] && usage
	  A=$OPTARG
	  ;;
      B ) [ -z "$OPTARG" ] && usage
	  B=$OPTARG
	  ;;
      C ) [ -z "$OPTARG" ] && usage
	  C=$OPTARG
	  ;;
      N ) [ -z "$OPTARG" ] && usage
	  N=$OPTARG
	  if ping -c1 $N >/dev/null 2>&1 ; then
		  nas="//$N"
	  else
		  bkn_error "can't ping NAS: $N (invalid hostname?)"
		  exit 1
	  fi
	  ;;
	  *) usage
  esac
done
shift $(($OPTIND - 1))

if [ -n "$1" ] ; then
	bkn_error "additional arguments... error."
	usage
fi

bkn_update_vars

case "$mode" in
	shell)
		bkn_debug_shell
		exit 0
		;;
	debug)
		# Trap functions very well, we enter debug shell
		# even if we 'exit' through bkn_fatal
		# but still we miss the bkn_release because
		# when the debug shell finishes, shell actually exits
		# FIXME: disable trap when entering in debug shell...
		trap bkn_debug_shell EXIT
		# Trap ERR not working at the moment
		# trap bkn_ERR ERR
		bkn_setup
		bkn_debug_shell
		echo "FIN"
		bkn_release
		exit 0
		;;
	backup_and_debug)
		trap bkn_debug_shell EXIT
		bkn_setup
		bkn_backup
		bkn_debug_shell
		bkn_release
		exit 0
		;;
	*) echo "normal operation..." ;;
esac

bkn_setup
bkn_backup
bkn_release

# Stages:
# - START
# - NAS_MOUNTED
# - NAS_MOUNTED_OK
# - LOOP_OK
# - BSF_OK
# - BSF_MOUNTED
# - BSF_MOUNTED_OK
# ...

# FS in BSF contents
# /MANIFEST <- what is this ?
# /README <- readme from dbdlb/mbclb
# /backup <- where to store backuped files&dirs
# /log <- real backup logs

